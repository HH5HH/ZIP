const test = require("node:test");
const assert = require("node:assert/strict");
const fs = require("node:fs");
const path = require("node:path");

const ROOT = path.resolve(__dirname, "..");
const SIDEPANEL_HTML_PATH = path.join(ROOT, "sidepanel.html");
const SIDEPANEL_JS_PATH = path.join(ROOT, "sidepanel.js");
const SIDEPANEL_CSS_PATH = path.join(ROOT, "sidepanel.css");
const CONTENT_PATH = path.join(ROOT, "content.js");
const BACKGROUND_PATH = path.join(ROOT, "background.js");
const SLACK_TOKEN_BRIDGE_PATH = path.join(ROOT, "slack-token-bridge.js");
const OPTIONS_PATH = path.join(ROOT, "options.js");

test("sidepanel uses SLACKTIVATED indicator + @ME action and removes legacy Slack login button", () => {
  const html = fs.readFileSync(SIDEPANEL_HTML_PATH, "utf8");
  const js = fs.readFileSync(SIDEPANEL_JS_PATH, "utf8");

  assert.match(html, /id="zipSlacktivatedBtn"/);
  assert.match(html, /id="zipSlacktivatedIcon"/);
  assert.match(html, /id="zipConfigGate"/);
  assert.match(html, /id="zipConfigDropZone"/);
  assert.match(html, /id="zipConfigFileInput"/);
  assert.match(html, /id="zipContextMenuClearKey"/);
  assert.match(html, /id="zipContextMenuClearKey"[^>]*class="[^"]*\bzip-context-menu-item-danger\b[^"]*"/);
  assert.match(html, /id="zipContextMenuToggleZdApi"[\s\S]*zip-context-menu-divider[\s\S]*id="zipContextMenuClearKey"/);
  assert.match(html, /id="zipContextMenuClearKey"[\s\S]*<\/button>\s*<\/div>\s*<div id="zipContextMenuThemeFlyout"/);
  assert.match(html, /id="zipTogglePassAiBtn"/);
  assert.match(html, /id="zipTogglePassAiIcon"/);
  assert.match(html, /id="zipSlackItToMeBtn"/);
  assert.match(html, /id="zipSlackItToMeBtn"[\s\S]*title="SLACK IT TO ME"/);
  assert.match(html, /<script src="slack-runtime-config\.js"><\/script>/);
  assert.doesNotMatch(html, /slack-oidc\.local\.js/);
  assert.match(html, /id="zipTogglePassAiBtn"[^>]*class="[^"]*\bhidden\b[^"]*"/);
  assert.doesNotMatch(html, /id="zipSlackItToMeBtn"[^>]*class="[^"]*\bhidden\b[^"]*"/);
  assert.doesNotMatch(html, /id="zipSlackLoginBtn"/);

  assert.match(js, /SLACKTIVATED_LOGIN_TOOLTIP/);
  assert.match(js, /slacktivatedBtn:\s*\$\("zipSlacktivatedBtn"\)/);
  assert.match(js, /contextMenuClearKey:\s*\$\("zipContextMenuClearKey"\)/);
  assert.match(js, /const ready = await refreshSlacktivatedState\(\{[\s\S]*allowOpenIdSilentProbe: true[\s\S]*allowSlackTabBootstrap: true[\s\S]*\}\)\.catch/);
  assert.match(js, /beginSlackLoginFlow\(\)\.catch/);
  assert.match(js, /const alreadyReady = await refreshPassAiSlackAuth\(\{ silent: true, allowOpenIdSilentProbe: false \}\)/);
  assert.match(js, /const openIdConfig = getPassAiSlackOpenIdConfig\(\);/);
  assert.match(js, /runPassAiSlackOpenIdAuth\(\{ interactive: false \}\)/);
  assert.match(js, /runPassAiSlackOpenIdAuth\(\{ interactive: true \}\)/);
  assert.match(js, /sendBackgroundRequest\("ZIP_SLACK_API_AUTH_TEST"/);
  assert.match(js, /existingSlackTabs = await querySlackTabsFromSidepanel\(\{ injectableOnly: true \}\)\.catch/);
  assert.match(js, /existingSlackTabs = await querySlackTabsFromSidepanel\(\{ injectableOnly: false \}\)\.catch/);
  assert.match(js, /opened = await focusSlackWorkspaceTab\(existingSlackTabs\[0\]\.id, loginUrl\)/);
  assert.match(js, /opened = await openSlackWorkspaceTab\(loginUrl, \{ active: true \}\)/);
  assert.match(js, /startPassAiSlackAuthPolling\(\);/);
  assert.doesNotMatch(js, /opened = await openSlackWorkspacePopup\(/);
  assert.doesNotMatch(js, /type:\s*"popup"/);
  assert.doesNotMatch(js, /function closePassAiSlackAuthWindow\(/);
  assert.match(js, /els\.passAiToggleBtn\.classList\.toggle\("hidden", !hasSelectedTicket\)/);
  assert.match(js, /els\.slackItToMeBtn\.classList\.remove\("hidden"\)/);
  assert.match(js, /const canUseSlackItToMe = slackReady/);
  assert.match(js, /function isPassAiSlacktivated\(\)\s*\{\s*return !!\(state\.passAiSlackReady && state\.passAiSlackWebReady\);\s*\}/);
  assert.match(js, /function buildPassAiSlackLoginUrl\(\)\s*\{\s*return buildPassAiSlackWorkspaceLandingUrl\(\);\s*\}/);
  assert.match(js, /getSlackTabCandidates\(\{\s*injectableOnly: true,\s*includeBackground: true,\s*workspaceOrigin\s*\}\)\.catch/);
  assert.match(js, /if \(!candidateIds\.length && String\(inner && inner\.action \|\| ""\) === "slackAuthTest"\)\s*\{/);
  assert.match(js, /function buildPassAiSlackWorkspaceLandingUrl\(\)\s*\{[\s\S]*PASS_AI_SLACK_WORKSPACE_ORIGIN \+ \"\/\"/);
  assert.match(js, /const PASS_AI_SLACK_OIDC_CLIENT_ID_STORAGE_KEY = "zip\.passAi\.slackOidc\.clientId";/);
  assert.match(js, /const PASS_AI_SLACK_OIDC_CLIENT_SECRET_STORAGE_KEY = "zip\.passAi\.slackOidc\.clientSecret";/);
  assert.match(js, /const PASS_AI_SLACK_OIDC_DEFAULT_REDIRECT_PATH = "slack-user";/);
  assert.match(js, /const PASS_AI_SLACK_OIDC_REDIRECT_URI_STORAGE_KEY = "zip\.passAi\.slackOidc\.redirectUri";/);
  assert.match(js, /const ZIP_SLACK_REDIRECT_URI_STORAGE_KEY = "zip_slack_redirect_uri";/);
  assert.match(js, /const PASS_AI_SLACK_API_BOT_TOKEN_STORAGE_KEY = "zip\.passAi\.slackApi\.botToken";/);
  assert.match(js, /const PASS_AI_SLACK_API_USER_TOKEN_STORAGE_KEY = "zip\.passAi\.slackApi\.userToken";/);
  assert.match(js, /function isAllowedSlackWorkspaceHost\(host, workspaceHost\)/);
  assert.match(js, /function normalizePassAiSlackAvatarUrl\(value\)/);
  assert.match(js, /parsed\.protocol/);
  assert.doesNotMatch(js, /hostname === "slack-edge\.com"/);
  assert.match(js, /function isTransientSlackAuthProbeFailureMessage\(message\)/);
  assert.match(js, /if \(wasReady && isTransientSlackAuthProbeFailureMessage\(message\)\) \{/);
  assert.match(js, /const allowSlackTabBootstrapCreate = opts\.allowSlackTabBootstrapCreate !== false;/);
  assert.match(js, /allowCreateTab:\s*allowSlackTabBootstrapCreate/);
  assert.match(js, /const bootstrapAllowCreateTab = opts\.allowCreateTab !== false;/);
  assert.match(js, /bootstrapSlackWorkspaceForMessaging\(\{ allowCreateTab: bootstrapAllowCreateTab \}\)/);
  assert.match(js, /const SLACK_BOOTSTRAP_MIN_GAP_MS = 8 \* 1000;/);
  assert.match(js, /const SLACK_WORKER_IDLE_CLOSE_MS = 12 \* 1000;/);
  assert.match(js, /slackWorkerTabId:\s*null/);
  assert.match(js, /slackWorkerWindowId:\s*null/);
  assert.match(js, /function clearSlackWorkerCloseTimer\(\)/);
  assert.match(js, /function setTrackedSlackWorkerTab\(tabId, windowId\)/);
  assert.match(js, /async function closeTrackedSlackWorkerTab\(reason\)/);
  assert.match(js, /function scheduleSlackWorkerTabClose\(reason, delayMs\)/);
  assert.match(js, /function maybeCloseZipOpenedSlackLoginTab\(reason, delayMs\)/);
  assert.match(js, /openSlackWorkspaceTab\(landingUrl, \{ active: false, worker: true \}\)/);
  assert.doesNotMatch(js, /chrome\.windows\.create\(\{ url: safeUrl, focused: false, state: "minimized" \}/);
  assert.doesNotMatch(js, /state:\s*"minimized"/);
  assert.match(js, /existingSlackTabs = existingSlackTabs\.filter\(\(tab\) => !isTrackedSlackWorkerTabId\(tab && tab\.id\)\)/);
  assert.match(js, /maybeCloseZipOpenedSlackLoginTab\("polling_login_complete", SLACK_LOGIN_TAB_CLOSE_DELAY_MS\)/);
  assert.match(js, /window\.addEventListener\("beforeunload"/);
  assert.match(js, /const sessionOnly = !!\(/);
  assert.match(js, /webReady:\s*!sessionOnly/);
  assert.match(js, /session_only:\s*sessionOnly/);
  assert.match(js, /recordSlackProbeEvent\("slack_probe_api_auth_ok"/);
  assert.match(js, /recordSlackProbeEvent\("slack_probe_web_auth_ok"/);
  assert.match(js, /recordSlackProbeEvent\("slack_probe_session_only"/);
  assert.match(js, /allowSlackTabBootstrapCreate:\s*false/);
  assert.match(js, /function getPassAiSlackApiTokenConfig\(\)/);
  assert.match(js, /runContextMenuAction\("clearZipKey"\)/);
  assert.match(js, /sendBackgroundRequest\("ZIP_SLACK_API_SEND_TO_SELF"/);
  assert.doesNotMatch(js, /sendToSlackTabWithAutoBootstrap\(\{\s*action:\s*"slackSendMarkdownToSelf"/);
  assert.doesNotMatch(js, /Slack API delivery unavailable; sending via Slack workspace session/);
  assert.doesNotMatch(js, /Preparing adobedx\.slack\.com web session for @ME/);
  assert.match(js, /function isZendeskActivityLoading\(\)/);
  assert.match(js, /function isSlackActivityLoading\(\)/);
  assert.match(js, /state\.passAiConversationInFlight/);
  assert.match(js, /function setPassAiConversationInFlight\(on\)/);
  assert.match(js, /setPassAiConversationInFlight\(true\);[\s\S]*requestPassAiConversation/);
  assert.match(js, /finally \{[\s\S]*setPassAiConversationInFlight\(false\);[\s\S]*setPassAiLoading\(false\);/);
  assert.match(js, /els\.topAvatarWrap\.classList\.toggle\("loading", zendeskLoading\)/);
  assert.match(js, /els\.slacktivatedBtn\.classList\.toggle\("is-network-loading", showSlackSpinner\)/);
  assert.doesNotMatch(js, /allowTabBootstrap/);
  assert.doesNotMatch(js, /ZIP_SLACK_OAUTH_SIGN_IN/);
  assert.doesNotMatch(js, /PASS_AI_SLACK_WORKSPACE_ORIGIN \+ \"\/signin\"/);
  assert.doesNotMatch(js, /datasetName:/);
  assert.match(js, /userToken:\s*slackApiTokens\.userToken \|\| ""/);
  assert.match(js, /botToken:\s*slackApiTokens\.botToken \|\| ""/);
  assert.match(js, /preferApiFirst:\s*true/);
  assert.match(js, /requireNativeNewMessage:\s*false/);
  assert.match(js, /autoBootstrapSlackTab:\s*true/);
  assert.match(js, /allowBotDelivery:\s*true/);
  assert.match(js, /skipUnreadMark:\s*true/);
  assert.doesNotMatch(js, /csvFilename:/);
  assert.doesNotMatch(js, /csvContent:/);
  assert.match(js, /function getSlackTicketEmailAddress\(row\)/);
  assert.match(js, /function formatSlackStatusIndicator\(value\)/);
  assert.match(js, /const ticketLabel = ticketId \? \("\#" \+ ticketId\) : "\#ticket";/);
  assert.match(js, /mailto:/);
  assert.match(js, /return "â€¢ " \+ parts\.join\(" "\);/);
  assert.match(js, /const signatureLine = "\/\/ <https:\/\/tve\.zendesk\.com\/hc\/en-us\/articles\/46503360732436-ZIP-TOOL-beta\|via ZipTool>";/);
  assert.match(js, /SLACK_IT_TO_ME delivered/);
  assert.doesNotMatch(js, /\*Visible Rows:\*/);
});

test("sidepanel styles include dedicated Slack avatar spinner class", () => {
  const css = fs.readFileSync(SIDEPANEL_CSS_PATH, "utf8");
  assert.match(css, /#zipSlacktivatedBtn\.is-network-loading::after/);
  assert.match(css, /animation:\s*zip-avatar-spin\s+0\.7s\s+linear\s+infinite/);
});

test("content script supports Slack auth identity details and @ME markdown DM action", () => {
  const source = fs.readFileSync(CONTENT_PATH, "utf8");
  assert.match(source, /async function slackAuthTestAction\(inner\)/);
  assert.match(source, /user_name:/);
  assert.match(source, /avatar_url:/);
  assert.match(source, /const hasSessionSignals = !!\(/);
  assert.match(source, /session_only:\s*true/);
  assert.match(source, /if \(looksSignedIn && hasSessionSignals\) \{/);
  assert.match(source, /Slack session detected; waiting for web token capture\./);
  assert.match(source, /\(\?:xoxe\\\.\)\?xox\[a-z\]-/);

  assert.match(source, /async function slackSendMarkdownToSelfAction\(inner\)/);
  assert.match(source, /async function slackMarkUnreadAction\(inner\)/);
  assert.match(source, /inner\.action === "slackMarkUnread"/);
  assert.match(source, /\/api\/chat\.postMessage/);
  assert.match(source, /\/api\/conversations\.open/);
  assert.match(source, /\/api\/conversations\.mark/);
  assert.match(source, /\/api\/subscriptions\.thread\.mark/);
  assert.doesNotMatch(source, /\/api\/files\.upload/);
  assert.doesNotMatch(source, /\/api\/files\.info/);
  assert.match(source, /inner\.action === "slackSendMarkdownToSelf"/);
});

test("Slack token bridge captures tokens from body and headers", () => {
  const source = fs.readFileSync(SLACK_TOKEN_BRIDGE_PATH, "utf8");
  assert.match(source, /\(\?:xoxe\\\.\)\?xox\[a-z\]-/);
  assert.match(source, /function inspectHeaders\(headers, depth\)/);
  assert.match(source, /if \(init && Object\.prototype\.hasOwnProperty\.call\(init, "headers"\)\) inspectHeaders\(init\.headers, 0\);/);
  assert.match(source, /if \(input && typeof input === "object" && Object\.prototype\.hasOwnProperty\.call\(input, "headers"\)\) inspectHeaders\(input\.headers, 0\);/);
  assert.match(source, /window\.XMLHttpRequest\.prototype\.setRequestHeader/);
  assert.match(source, /inspect\(value, 0\);/);
});

test("options normalizeSlackToken accepts modern Slack user token prefixes", () => {
  const source = fs.readFileSync(OPTIONS_PATH, "utf8");
  assert.match(source, /function normalizeSlackToken\(value\)/);
  assert.match(source, /\^\(\?:xoxe\\\.\)\?xox\[a-z\]-/);
});

test("background removes legacy Slack OAuth and popup-login handlers", () => {
  const source = fs.readFileSync(BACKGROUND_PATH, "utf8");
  assert.doesNotMatch(source, /ZIP_SLACK_OAUTH_STATUS/);
  assert.doesNotMatch(source, /ZIP_SLACK_OAUTH_SIGN_IN/);
  assert.doesNotMatch(source, /ZIP_SLACK_OAUTH_SIGN_OUT/);
  assert.doesNotMatch(source, /ZIP_PASS_AI_SLACK_SEND/);
  assert.doesNotMatch(source, /ZIP_PASS_AI_SLACK_POLL/);
  assert.doesNotMatch(source, /ZIP_OPEN_SLACK_LOGIN/);
  assert.doesNotMatch(source, /ZIP_CLOSE_WINDOW/);
  assert.match(source, /SLACK_OPENID_AUTHORIZE_URL/);
  assert.match(source, /SLACK_OPENID_TOKEN_URL/);
  assert.match(source, /SLACK_OPENID_USERINFO_URL/);
  assert.match(source, /MENU_CLEAR_KEY/);
  assert.match(source, /MENU_CLEAR_KEY_SEPARATOR/);
  assert.match(source, /MENU_CLEAR_KEY_LABEL/);
  assert.match(source, /msg\.type === "ZIP_CHECK_SECRETS"/);
  assert.match(source, /msg\.type === "ZIP_CLEAR_KEY"/);
  assert.match(source, /msg\.type === "ZIP_IMPORT_KEY_PAYLOAD"/);
  assert.match(source, /type:\s*"ZIP_KEY_CLEARED"/);
  assert.match(source, /msg\.type === "ZIP_RUN_LOCALSTORAGE_MIGRATION"/);
  assert.match(source, /action === "clearZipKey"/);
  assert.match(source, /id:\s*MENU_CLEAR_KEY_SEPARATOR,[\s\S]*type:\s*"separator"[\s\S]*id:\s*MENU_CLEAR_KEY/);
  assert.match(source, /const SLACK_OPENID_DEFAULT_REDIRECT_PATH = "slack-user";/);
  assert.match(source, /const ZIP_SLACK_REDIRECT_URI_STORAGE_KEY = "zip_slack_redirect_uri";/);
  assert.match(source, /function resolveSlackOpenIdRedirectUriCandidates\(config\)/);
  assert.match(source, /function isSlackOpenIdRedirectMismatchError\(message\)/);
  assert.match(source, /msg\.type === "ZIP_SLACK_OPENID_AUTH"/);
  assert.match(source, /msg\.type === "ZIP_SLACK_OPENID_STATUS"/);
  assert.match(source, /msg\.type === "ZIP_SLACK_API_AUTH_TEST"/);
  assert.match(source, /msg\.type === "ZIP_SLACK_API_SEND_TO_SELF"/);
  assert.match(source, /async function slackMarkUnreadViaWorkspaceSession\(input, reasonCode\)/);
  assert.match(source, /action:\s*"slackMarkUnread"/);
  assert.match(source, /async function markSlackMessageUnreadViaApiToken\(workspaceOrigin,\s*token,\s*channelId,\s*messageTs,\s*readCursorTs\)/);
  assert.match(source, /async function slackSendMarkdownToSelfViaApi\(input\)/);
  assert.match(source, /const allowWorkspaceTabBootstrap = body\.autoBootstrapSlackTab !== false;/);
  assert.match(source, /async function slackSendMarkdownToSelfViaWorkspaceSession\(input, reasonCode\)/);
  assert.match(source, /function isAllowedSlackWorkspaceHost\(host, workspaceHost\)/);
  assert.match(source, /if \(!isAllowedSlackWorkspaceHost\(tabHost, expectedHost\)\) continue;/);
  assert.match(source, /slackSendMarkdownToSelfViaWorkspaceSession\(body,\s*"workspace_session_primary"\)/);
  assert.match(source, /primarySessionDelivery[\s\S]*primarySessionDelivery\.ok/);
  assert.match(source, /if \(allowBotDelivery\) \{[\s\S]*const botFallback = await slackSendMarkdownToSelfViaBotApi\(body,\s*tokens\);/);
  assert.match(source, /const requireNativeNewMessage = body\.requireNativeNewMessage !== false;/);
  assert.match(source, /async function slackSendMarkdownToSelfViaBotApi\(input,\s*resolvedTokens\)/);
  assert.match(source, /const botDeliveryToken = normalizeSlackApiToken\(tokens\.botToken\);/);
  assert.match(source, /const botCandidates = Array\.isArray\(tokens && tokens\.botCandidates\)/);
  assert.match(source, /const userDeliveryToken = normalizeSlackApiToken\(tokens\.userToken\);/);
  assert.match(source, /const userCandidates = Array\.isArray\(tokens && tokens\.userCandidates\)/);
  assert.match(source, /const hasUserOAuthCandidate = tokenAttempts\.length > 0;/);
  assert.match(source, /if \(!hasUserOAuthCandidate\) \{/);
  assert.match(source, /const tokenAttempts = \[];/);
  assert.match(source, /for \(let i = 0; i < userCandidates\.length; i \+= 1\) \{/);
  assert.match(source, /for \(let i = 0; i < tokenAttempts\.length; i \+= 1\)/);
  assert.match(source, /function isSlackUserOAuthToken\(value\)/);
  assert.doesNotMatch(source, /return \/\^xoxp-\//);
  assert.match(source, /\^\(\?:xoxe\\\.\)\?xox\[a-z\]-/);
  assert.doesNotMatch(source, /Active Slack API user does not match the SLACKTIVATED user\./);
  assert.match(source, /function isSlackBotApiToken\(value\)/);
  assert.match(source, /function isSlackTokenInvalidationCode\(code\)/);
  assert.match(source, /async function invalidateStoredSlackToken\(token\)/);
  assert.match(source, /const SLACK_TOKEN_FAILURE_BACKOFF_MS = 2 \* 60 \* 1000;/);
  assert.match(source, /const slackTokenBackoffUntilByToken = new Map\(\);/);
  assert.match(source, /function markSlackTokenBackoff\(token\)/);
  assert.match(source, /function clearSlackTokenBackoff\(token\)/);
  assert.match(source, /if \(isSlackTokenTemporarilyBackedOff\(attemptToken\)\) \{/);
  assert.match(source, /if \(isSlackTokenInvalidationCode\(lastFailureCode\)\) \{/);
  assert.match(source, /SLACK_IT_TO_ME requires a Slack bot token for guaranteed new-message delivery\./);
  assert.match(source, /SLACK_IT_TO_ME requires a Slack user\/session token for DM delivery\./);
  assert.match(source, /\/api\/chat\.postMessage/);
  assert.match(source, /\/api\/conversations\.open/);
  assert.doesNotMatch(source, /if \(isBotToken\) \{/);
  assert.match(source, /delivery_mode:\s*"bot_direct_channel"/);
  assert.match(source, /delivery_mode:\s*"user_direct_channel"/);
  assert.match(source, /delivery_mode:\s*"workspace_session_dm"/);
  assert.match(source, /autoBootstrapSlackTab:\s*allowWorkspaceTabBootstrap/);
  assert.doesNotMatch(source, /requires a Slack user token/);
  assert.doesNotMatch(source, /files\.getUploadURLExternal/);
  assert.doesNotMatch(source, /Download: <"\s*\+\s*csvPermalink\s*\+\s*"\|CSV>/);
  assert.match(source, /launchWebAuthFlow/);
  assert.doesNotMatch(source, /type:\s*["']popup["']/);
});
